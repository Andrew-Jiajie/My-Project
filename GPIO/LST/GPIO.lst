C51 COMPILER V9.53.0.0   GPIO                                                              01/31/2018 11:45:08 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE GPIO
OBJECT MODULE PLACED IN .\Output\GPIO.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Code\GPIO.C LARGE OPTIMIZE(4,SPEED) BROWSE INCDIR(..\..\Include) DEFINE(
                    -FOSC_160000) DEBUG OBJECTEXTEND PRINT(.\LST\GPIO.lst) TABS(2) OBJECT(.\Output\GPIO.obj)

line level    source

   1          /*--------------------------------------------------------------------------------------------------------
             --*/
   2          /*                                                                                                        
             - */
   3          /* Copyright(c) 2017 Nuvoton Technology Corp. All rights reserved.                                        
             - */
   4          /*                                                                                                        
             - */
   5          /*--------------------------------------------------------------------------------------------------------
             --*/
   6          
   7          //********************************************************************************************************
             -***
   8          //  Website: http://www.nuvoton.com
   9          //  E-Mail : MicroC-8bit@nuvoton.com
  10          //  Date   : Jan/21/2017
  11          //********************************************************************************************************
             -***
  12          
  13          //********************************************************************************************************
             -***
  14          //  File Function: N76E003 GPIO demo code
  15          //********************************************************************************************************
             -***
  16          #include "N76E003.h"
  17          #include "SFR_Macro.h"
  18          #include "Function_define.h"
  19          #include "Common.h"
  20          #include "Delay.h"
  21          
  22          #define DEBUG 0
  23          #define HIGH 1
  24          #define LOW 0
  25          
  26          #define PLAYING 1
  27          #define STOP 0
  28          #define ON 1
  29          #define OFF 0
  30          #define SOURCE_TF 2
  31          #define SOURCE_FLASH 3
  32          #define MINIT   60
  33          
  34          #define HEAD_MUSIC_NUM 2
  35          
  36          void Delay_1ms(int time)
  37          {
  38   1        int i,j;
  39   1        for(j=0; j<time; j++)
  40   1          for (i = 0; i < 729; i++);
  41   1      }
  42          
  43          void Delay_100us(int time)
  44          {
  45   1        int i,j;
C51 COMPILER V9.53.0.0   GPIO                                                              01/31/2018 11:45:08 PAGE 2   

  46   1        for(j=0; j<time; j++)
  47   1          for (i = 0; i < 72; i++);
  48   1      }
  49          
  50          /*------------------------------------------------
  51          The main C function.  Program execution starts
  52          here after stack initialization.
  53          ------------------------------------------------*/
  54          typedef unsigned char u8;
  55          u8 music_play[]={0x01};
  56          u8 music_stop[]={0x0E};
  57          u8 music_next[]={0x03};
  58          u8 volume_set[]={0x31,0x10};
  59          u8 source_TF[]={0x35,0x01};
  60          u8 source_FLASH[]={0x35,0x04};
  61          u8 music_for_head[]={0x42,0x01,0x02};
  62          u8 music_for_next[]={0x41,0x00,0x01};
  63          u8 music_in_root[]={0x41,0x00,0x01};
  64          u8 folder_and_num[]={0x42,0x01,0x01};
  65          u8 chip_sleep[]={0x35,0x03};
  66          u8 chip_wakeup[]={0x35,0x02};
  67          
  68          u8 music_state[]={0x10};
  69          u8 music_number[]={0x17};
  70          u8 volume_get[]={0x11};
  71          u8 current_source[]={0x18};
  72          
  73          u8 return_ok[]={0x7E,0x02,0x00,0xEF};
  74          u8 return_finished[]={0x7E,0x04,   0x3E,    0x00,0x00,0xEF};  //current music finished
  75          u8 return_state[]={0x7E,0x03,0x10,0x00,   //0(STOP) 1(PLAY) 2(PAUS) 3(FF) 4(FR)
  76                            0xEF,0x7E,0x02,0x00,0xEF}; //when music_state send, will return the value
  77          u8 state_str[12];
  78          u8 get_result()
  79          {
  80   1          int result_num=0;
  81   1        int timeout=250;
  82   1      
  83   1        while(!RI && timeout--){
  84   2          Delay_100us(1);   //delay 25ms
  85   2        }
  86   1          while (RI) {
  87   2            state_str[result_num++]=Receive_Data_From_UART0();
  88   2          timeout=8000;
  89   2          while(!RI && timeout--);
  90   2          }
  91   1          return result_num;
  92   1      }
  93          
  94          void send_cmd(u8* cmd, u8 num){
  95   1        u8 count=0;
  96   1        u8 command[15];
  97   1        u8 tmp_cnt=0;
  98   1        int out_cnt=0;
  99   1        
 100   1        command[count++]=0x7E;
 101   1        command[count++]=0x01+num;
 102   1        while(tmp_cnt<num){
 103   2          command[count++]=*(cmd+tmp_cnt);
 104   2          tmp_cnt++;
 105   2        }
 106   1        command[count]=0xEF;
 107   1        while(out_cnt<=count){
C51 COMPILER V9.53.0.0   GPIO                                                              01/31/2018 11:45:08 PAGE 3   

 108   2          Send_Data_To_UART0(command[out_cnt++]);
 109   2        }
 110   1      }
 111          
 112          int Control_CMD(u8* cmd, u8 num){
 113   1        int set_correct=0;
 114   1          u8 timeout=2;
 115   1          int str_num;
 116   1          int j;
 117   1          while(!set_correct && timeout--){
 118   2              send_cmd(cmd, num);
 119   2            str_num = get_result();
 120   2              for(j=0; j<str_num-3; j++){
 121   3                if(state_str[j]==0x7e && state_str[j+1]==0x02 && state_str[j+2]==0x00 && state_str[j+3]==0xef){
 122   4                    set_correct=1;
 123   4              return 0;
 124   4                      break;
 125   4                }
 126   3              }
 127   2          }
 128   1        return -1;
 129   1      }
 130          
 131          
 132          int Get_Play_State()
 133          {
 134   1          u8 timeout=2;
 135   1        int str_num;
 136   1        int j;
 137   1        
 138   1          while(timeout--){
 139   2            send_cmd(music_state, sizeof(music_state));
 140   2            str_num = get_result();
 141   2            for(j=0; j<str_num-3; j++){
 142   3                if(state_str[j]==0x7e && state_str[j+2]==0x10){
 143   4                  return state_str[j+3];
 144   4                }
 145   3            }
 146   2          Delay_1ms(20);
 147   2          }
 148   1        return -1;
 149   1      }
 150          
 151          int Get_total_number()
 152          {
 153   1          u8 timeout=2;
 154   1        int str_num;
 155   1        int j;
 156   1        
 157   1          while(timeout--){
 158   2            send_cmd(music_number, sizeof(music_number));
 159   2            str_num = get_result();
 160   2            for(j=0; j<str_num-4; j++){
 161   3                if(state_str[j]==0x7e && state_str[j+2]==0x17){
 162   4              return state_str[j+4];
 163   4                }
 164   3            }
 165   2          Delay_1ms(20);
 166   2          }
 167   1        return -1;
 168   1      }
 169          
C51 COMPILER V9.53.0.0   GPIO                                                              01/31/2018 11:45:08 PAGE 4   

 170          int play_head_music(){
 171   1        Control_CMD(music_for_head, sizeof(music_for_head));
 172   1        music_for_head[2]++;
 173   1        if(LOBYTE(music_for_head[2])>HEAD_MUSIC_NUM){
 174   2          music_for_head[2]=1;
 175   2        }
 176   1      }
 177          
 178          int play_body_music()
 179          {
 180   1        int total_music=Get_total_number();
 181   1        if(total_music > HEAD_MUSIC_NUM){
 182   2          Control_CMD(music_for_next, sizeof(music_for_next));
 183   2          music_for_next[2]++;
 184   2          if(LOBYTE(music_for_next[2])>total_music-HEAD_MUSIC_NUM){
 185   3            music_for_next[2]=1;
 186   3          }
 187   2        }
 188   1      }
 189          
 190          int Specify_Volume(u8 num)
 191          {
 192   1        
 193   1      #if 0
                volume_set[1] = num;
                Control_CMD(volume_set, sizeof(volume_set));
              #else
 197   1          int set_correct=0;
 198   1          u8 timeout=3;
 199   1        int str_num;
 200   1        int j;
 201   1        volume_set[1] = num;
 202   1        
 203   1          while(!set_correct && timeout--){
 204   2            send_cmd(volume_set, sizeof(volume_set));
 205   2          Delay_1ms(13);  // 13ms is the best timedelay for volume set!
 206   2            send_cmd(volume_get, sizeof(volume_get));
 207   2            str_num = get_result();
 208   2            for(j=0; j<str_num-3; j++){
 209   3                if(state_str[j]==0x7e && state_str[j+2]==0x11 && state_str[j+3]==num){
 210   4                  set_correct=1;
 211   4              return 0;
 212   4                }
 213   3            }
 214   2          }
 215   1        return -1;
 216   1      #endif
 217   1      }
 218          
 219          #define setbit(x,y) x|=(1<<y) //将X的第Y位置1
 220          #define testbit(x,y) x&(1<<y) //测试X的第Y位置
 221          #define clrbit(x,y) x&=!(1<<y) //将X的第Y位清0
 222          
 223          int button_trig_state=HIGH;
 224          int play_trig_state=HIGH;
 225          int charge_trig_state=HIGH;
 226          
 227          int Button_state=-1;
 228          int Play_state=STOP;
 229          int Charge_state=OFF;
 230          int Reset_system=-1;
 231          void PinInterrupt_ISR (void) interrupt 7
C51 COMPILER V9.53.0.0   GPIO                                                              01/31/2018 11:45:08 PAGE 5   

 232          {
 233   1        if (testbit(PIF,7)) //SWITCH PIN
 234   1        {
 235   2          clrbit(PIF,7);
 236   2          Delay_1ms(15);
 237   2          if(button_trig_state==LOW && P17==LOW){
 238   3            Enable_BIT7_RasingEdge_Trig;
 239   3            button_trig_state=HIGH;
 240   3            Button_state=1;
 241   3          }else if(button_trig_state==HIGH && P17==HIGH){
 242   3            Enable_BIT7_FallEdge_Trig;
 243   3            button_trig_state=LOW;
 244   3            Button_state=0;
 245   3          }
 246   2          clr_PD;
 247   2        }
 248   1        if (testbit(PIF,3)) //BUSY PIN
 249   1        {
 250   2          clrbit(PIF,3);
 251   2          Delay_1ms(2);
 252   2          if(play_trig_state==LOW && P13==LOW){
 253   3            Enable_BIT3_RasingEdge_Trig;
 254   3            play_trig_state=HIGH;
 255   3            Play_state=PLAYING;
 256   3          }else if(play_trig_state==HIGH && P13==HIGH){
 257   3            Enable_BIT3_FallEdge_Trig;
 258   3            play_trig_state=LOW;
 259   3            Play_state=STOP;
 260   3          }
 261   2          //Send_Data_To_UART0(0xcc);
 262   2          clr_PD;
 263   2        }
 264   1        if (testbit(PIF,2)) //USB PIN
 265   1        {
 266   2          clrbit(PIF,2);
 267   2          Delay_1ms(10);
 268   2          if(charge_trig_state==LOW && P13==LOW){
 269   3            Enable_BIT2_RasingEdge_Trig;
 270   3            charge_trig_state=HIGH;
 271   3            Charge_state=ON;
 272   3          }else if(charge_trig_state==HIGH && P13==HIGH){
 273   3            Enable_BIT2_FallEdge_Trig;
 274   3            charge_trig_state=LOW;
 275   3            Charge_state=OFF;
 276   3            Reset_system=1;
 277   3          }
 278   2          //Send_Data_To_UART0(0xcc);
 279   2          clr_PD;
 280   2        }
 281   1        return;
 282   1      }
 283          
 284          unsigned long wake_time=0;
 285          unsigned long timer_count=0;
 286          int Power_state=ON;
 287          
 288          /*********************************************************************************************************
             -***
 289          *    TIMER 0 interrupt subroutine
 290          **********************************************************************************************************
             -**/
 291          void Timer0_ISR (void) interrupt 1          //interrupt address is 0x000B
C51 COMPILER V9.53.0.0   GPIO                                                              01/31/2018 11:45:08 PAGE 6   

 292          {
 293   1          clr_TF0;
 294   1          clr_TR0;                                    //Stop Timer0
 295   1              TL0 = LOBYTE(TIMER_DIV12_VALUE_40ms);     //Find  define in "Function_define.h" "TIMER VALUE"
 296   1              TH0 = HIBYTE(TIMER_DIV12_VALUE_40ms);
 297   1          set_TR0;                                    //Start Timer0
 298   1          timer_count+=40;
 299   1          if(timer_count >= 1000){
 300   2            timer_count=0;
 301   2            wake_time++;
 302   2          }
 303   1          //Send_Data_To_UART0(0xcc);
 304   1      }
 305          
 306          void audio_power_on()
 307          {
 308   1        int timeout=25; //500ms for timeout
 309   1        int chip_ready=-1;
 310   1        P11=HIGH;
 311   1        while(timeout-- && chip_ready==-1){
 312   2          Delay_1ms(20);
 313   2          chip_ready=Specify_Volume(28);
 314   2          //Send_Data_To_UART0(0xCC);
 315   2        }
 316   1        Delay_1ms(110);
 317   1        Power_state=ON;
 318   1      }
 319          
 320          void audio_power_off()
 321          {
 322   1        clr_TR0;                                    //Stop Timer0
 323   1        wake_time=0;
 324   1        P11=LOW;
 325   1        Power_state=OFF;
 326   1        Send_Data_To_UART0(0xBB);
 327   1        set_PD;
 328   1        set_TR0;                                    //Timer0 run
 329   1      }
 330          
 331          void init_LED(){
 332   1        
 333   1      }
 334          
 335          
 336          int Head_Music_Play=0;
 337          int Body_Music_Play=0;
 338          void main (void) 
 339          {
 340   1        int music_num=1;
 341   1        int play_state=-1;
 342   1        
 343   1        //set_PD;                 //powerdown directly 131.5uA
 344   1        Set_All_GPIO_Quasi_Mode;          // Define in Function_define.h
 345   1        P11_PushPull_Mode;
 346   1      
 347   1      #if 1
 348   1          PWM0_P12_OUTPUT_ENABLE;
 349   1          PWM1_P14_OUTPUT_ENABLE;
 350   1          PWM3_P00_OUTPUT_ENABLE;
 351   1        
 352   1          PWM_IMDEPENDENT_MODE;
 353   1          PWM_CLOCK_DIV_8;
C51 COMPILER V9.53.0.0   GPIO                                                              01/31/2018 11:45:08 PAGE 7   

 354   1          PWMPH = 0x07;
 355   1          PWMPL = 0xCF;
 356   1      /**********************************************************************
 357   1        PWM frequency = Fpwm/((PWMPH,PWMPL) + 1) <Fpwm = Fsys/PWM_CLOCK_DIV> 
 358   1                      = (16MHz/8)/(0x7CF + 1)
 359   1                      = 1KHz (1ms)
 360   1      ***********************************************************************/
 361   1        
 362   1          PWM0H = 0x00;         
 363   1          PWM0L = 0xCF;
 364   1          PWM1H = 0x01;           
 365   1          PWM1L = 0xCF;
 366   1          PWM3H = 0x01;           
 367   1          PWM3L = 0xCF;
 368   1          
 369   1      //-------- PWM start run--------------
 370   1          set_LOAD;
 371   1          set_PWMRUN;
 372   1      #else
                  P00_PushPull_Mode;
                  P12_PushPull_Mode;
                  P14_PushPull_Mode;
                  P00=0;
                  P12=0;
                  P14=0;
              #endif
 380   1          while(1);
 381   1      
 382   1        InitialUART0_Timer1(9600);
 383   1        set_CLOEN; 
 384   1        audio_power_on();
 385   1        //Delay_1ms(250);     //800ms delay for audio chip get ready
 386   1      
 387   1      #if 1
 388   1        TIMER0_MODE0_ENABLE;                        //Timer 0 and Timer 1 mode configuration
 389   1      
 390   1        clr_T0M;
 391   1          TMOD |= 0x01;                               //Timer0 is 16-bit mode
 392   1        
 393   1          TL0 = LOBYTE(TIMER_DIV12_VALUE_40ms);     //Find  define in "Function_define.h" "TIMER VALUE"
 394   1          TH0 = HIBYTE(TIMER_DIV12_VALUE_40ms);
 395   1          
 396   1        set_ET0;                                    //enable Timer0 interrupt
 397   1        set_EA;                                     //enable interrupts
 398   1        
 399   1        set_TR0;                                    //Timer0 run
 400   1      #endif
 401   1      
 402   1      #if 1
 403   1        P17_Input_Mode;
 404   1        set_P0S_7;
 405   1        Enable_BIT7_FallEdge_Trig;
 406   1        button_trig_state=LOW;
 407   1      
 408   1        P13_Input_Mode;
 409   1        set_P0S_3;
 410   1        Enable_BIT3_FallEdge_Trig;
 411   1        play_trig_state=LOW;
 412   1        
 413   1        
 414   1        P30_Input_Mode;
 415   1        Enable_BIT0_FallEdge_Trig;
C51 COMPILER V9.53.0.0   GPIO                                                              01/31/2018 11:45:08 PAGE 8   

 416   1      
 417   1        Enable_INT_Port1;
 418   1        set_EPI;              // Enable pin interrupt
 419   1        set_EX0;
 420   1        set_EA;               // global enable bit
 421   1      
 422   1      #endif
 423   1        Specify_Volume(30);
 424   1        //Control_CMD(folder_and_num, sizeof(folder_and_num));
 425   1        while(1){
 426   2          //set_PD;         //powerdown here can be 145.8uA
 427   2          //play_state=Get_Play_State();
 428   2          if(Button_state==1){
 429   3            Button_state=-1;
 430   3            if(Power_state==OFF){
 431   4              audio_power_on();
 432   4            }
 433   3            play_head_music();
 434   3            //Head_Music_Play=1;
 435   3            Body_Music_Play=0;
 436   3          }
 437   2          if(Button_state==0){
 438   3            Button_state=-1;
 439   3            Body_Music_Play=1;
 440   3          }
 441   2          if(Play_state==PLAYING || Charge_state==ON){
 442   3            wake_time = 0;
 443   3            //Send_Data_To_UART0(0xBB);
 444   3            set_IDL;
 445   3          }
 446   2          if(Reset_system==1){
 447   3            Reset_system=-1;
 448   3            set_SWRST;
 449   3          }
 450   2          if(Charge_state==ON && Power_state==OFF){
 451   3            audio_power_on();
 452   3          }
 453   2          if(Play_state==STOP && Charge_state==OFF && wake_time > MINIT/12){
 454   3            audio_power_off();
 455   3          }
 456   2      #if 0
                  if(Play_state==STOP && Head_Music_Play==1){
                    Head_Music_Play=0;
                  }
              #endif
 461   2          if(Play_state==STOP && Body_Music_Play==1){
 462   3            if(Power_state==ON){
 463   4              play_body_music();
 464   4            }
 465   3            Body_Music_Play=0;
 466   3          }
 467   2        }
 468   1      }
*** WARNING C290 IN LINE 176 OF Code\GPIO.C: missing return value
*** WARNING C290 IN LINE 188 OF Code\GPIO.C: missing return value
*** WARNING C294 IN LINE 382 OF Code\GPIO.C: unreachable code


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2165    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     88      56
C51 COMPILER V9.53.0.0   GPIO                                                              01/31/2018 11:45:08 PAGE 9   

   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  3 WARNING(S),  0 ERROR(S)
