C51 COMPILER V9.53.0.0   GPIO                                                              01/08/2018 19:20:12 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE GPIO
OBJECT MODULE PLACED IN .\Output\GPIO.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Code\GPIO.C LARGE OPTIMIZE(4,SPEED) BROWSE INCDIR(..\..\Include) DEFINE(
                    -FOSC_160000) DEBUG OBJECTEXTEND PRINT(.\LST\GPIO.lst) TABS(2) OBJECT(.\Output\GPIO.obj)

line level    source

   1          /*--------------------------------------------------------------------------------------------------------
             --*/
   2          /*                                                                                                        
             - */
   3          /* Copyright(c) 2017 Nuvoton Technology Corp. All rights reserved.                                        
             - */
   4          /*                                                                                                        
             - */
   5          /*--------------------------------------------------------------------------------------------------------
             --*/
   6          
   7          //********************************************************************************************************
             -***
   8          //  Website: http://www.nuvoton.com
   9          //  E-Mail : MicroC-8bit@nuvoton.com
  10          //  Date   : Jan/21/2017
  11          //********************************************************************************************************
             -***
  12          
  13          //********************************************************************************************************
             -***
  14          //  File Function: N76E003 GPIO demo code
  15          //********************************************************************************************************
             -***
  16          #include "N76E003.h"
  17          #include "SFR_Macro.h"
  18          #include "Function_define.h"
  19          #include "Common.h"
  20          #include "Delay.h"
  21          
  22          #define DEBUG 0
  23          #define HIGH 1
  24          #define LOW 0
  25          
  26          #define PLAYING 1
  27          #define STOP 0
  28          
  29          void Delay_1ms(int time)
  30          {
  31   1        int i,j;
  32   1        for(j=0; j<time; j++)
  33   1          for (i = 0; i < 729; i++);
  34   1      }
  35          
  36          void Delay_100us(int time)
  37          {
  38   1        int i,j;
  39   1        for(j=0; j<time; j++)
  40   1          for (i = 0; i < 72; i++);
  41   1      }
  42          
  43          /*------------------------------------------------
  44          The main C function.  Program execution starts
  45          here after stack initialization.
C51 COMPILER V9.53.0.0   GPIO                                                              01/08/2018 19:20:12 PAGE 2   

  46          ------------------------------------------------*/
  47          typedef unsigned char u8;
  48          u8 music_play[]={0x01};
  49          u8 music_stop[]={0x0E};
  50          u8 music_next[]={0x03};
  51          u8 volume_set[]={0x31,0x10};
  52          u8 source_TF[]={0x35,0x01};
  53          u8 source_FLASH[]={0x35,0x04};
  54          u8 music_in_root[]={0x34,0x03,0x01};
  55          u8 folder_and_num[]={0x42,0x02,0x01};
  56          u8 chip_sleep[]={0x35,0x03};
  57          u8 chip_wakeup[]={0x35,0x02};
  58          
  59          u8 music_state[]={0x10};
  60          u8 volume_get[]={0x11};
  61          
  62          u8 return_ok[]={0x7E,0x02,0x00,0xEF};
  63          u8 return_finished[]={0x7E,0x04,   0x3E,    0x00,0x00,0xEF};  //current music finished
  64          u8 return_state[]={0x7E,0x03,0x10,0x00,   //0(STOP) 1(PLAY) 2(PAUS) 3(FF) 4(FR)
  65                            0xEF,0x7E,0x02,0x00,0xEF}; //when music_state send, will return the value
  66          u8 state_str[12];
  67          u8 get_result()
  68          {
  69   1          int result_num=0;
  70   1        int timeout=250;
  71   1      
  72   1        while(!RI && timeout--){
  73   2          Delay_100us(1);   //delay 25ms
  74   2        }
  75   1          while (RI) {
  76   2            state_str[result_num++]=Receive_Data_From_UART0();
  77   2          timeout=8000;
  78   2          while(!RI && timeout--);
  79   2          }
  80   1          return result_num;
  81   1      }
  82          
  83          void send_cmd(u8* cmd, u8 num){
  84   1        u8 count=0;
  85   1        u8 command[15];
  86   1        u8 tmp_cnt=0;
  87   1        int out_cnt=0;
  88   1        
  89   1        command[count++]=0x7E;
  90   1        command[count++]=0x01+num;
  91   1        while(tmp_cnt<num){
  92   2          command[count++]=*(cmd+tmp_cnt);
  93   2          tmp_cnt++;
  94   2        }
  95   1        command[count]=0xEF;
  96   1        while(out_cnt<=count){
  97   2          Send_Data_To_UART0(command[out_cnt++]);
  98   2        }
  99   1      }
 100          
 101          void Control_CMD(u8* cmd, u8 num){
 102   1        int set_correct=0;
 103   1          u8 timeout=3;
 104   1          int str_num;
 105   1          int j;
 106   1          while(!set_correct && timeout--){
 107   2              send_cmd(cmd, num);
C51 COMPILER V9.53.0.0   GPIO                                                              01/08/2018 19:20:12 PAGE 3   

 108   2            str_num = get_result();
 109   2      #if DEBUG
                    Send_Data_To_UART0(0xAA);
                    for(j=0; j<str_num; j++){
                      Send_Data_To_UART0(state_str[j]);
                    }
                    Send_Data_To_UART0(0xBB);
              #endif
 116   2              for(j=0; j<str_num-3; j++){
 117   3                if(state_str[j]==0x7e && state_str[j+1]==0x02 && state_str[j+2]==0x00 && state_str[j+3]==0xef){
 118   4                    set_correct=1;
 119   4      #if DEBUG
                        Send_Data_To_UART0(0xCC);
              #endif
 122   4                      break;
 123   4                }
 124   3              }
 125   2          }
 126   1      
 127   1      }
 128          
 129          
 130          int Get_Play_State()
 131          {
 132   1          u8 timeout=3;
 133   1        int str_num;
 134   1        int j;
 135   1        
 136   1          while(timeout--){
 137   2            send_cmd(music_state, sizeof(music_state));
 138   2            str_num = get_result();
 139   2            for(j=0; j<str_num-3; j++){
 140   3                if(state_str[j]==0x7e && state_str[j+2]==0x10){
 141   4                  return state_str[j+3];
 142   4                }
 143   3            }
 144   2          Delay_1ms(20);
 145   2          }
 146   1        return -1;
 147   1      }
 148          
 149          void Specify_Volume(u8 num)
 150          {
 151   1        
 152   1      #if 0
                volume_set[1] = num;
                Control_CMD(volume_set, sizeof(volume_set));
              #else
 156   1          int set_correct=0;
 157   1          u8 timeout=3;
 158   1        int str_num;
 159   1        int j;
 160   1        volume_set[1] = num;
 161   1        
 162   1          while(!set_correct && timeout--){
 163   2            send_cmd(volume_set, sizeof(volume_set));
 164   2          Delay_1ms(13);  // 13ms is the best timedelay for volume set!
 165   2            send_cmd(volume_get, sizeof(volume_get));
 166   2            str_num = get_result();
 167   2      #if DEBUG
                  Send_Data_To_UART0(0xAA);
                  for(j=0; j<str_num; j++){
C51 COMPILER V9.53.0.0   GPIO                                                              01/08/2018 19:20:12 PAGE 4   

                    Send_Data_To_UART0(state_str[j]);
                  }
                  Send_Data_To_UART0(0xBB);
              #endif
 174   2            for(j=0; j<str_num-3; j++){
 175   3                if(state_str[j]==0x7e && state_str[j+2]==0x11 && state_str[j+3]==num){
 176   4                  set_correct=1;
 177   4      #if DEBUG
                      Send_Data_To_UART0(0xCC);
              #endif
 180   4                  break;
 181   4                }
 182   3            }
 183   2          }
 184   1      #endif
 185   1      }
 186          
 187          int trig_state=HIGH;
 188          int Button_state=-1;
 189          void PinInterrupt_ISR (void) interrupt 7
 190          {
 191   1        if (PIF == 0x80)
 192   1        {
 193   2          PIF =0;
 194   2          Delay_1ms(20);
 195   2          if(trig_state==LOW && P17==LOW){
 196   3            Enable_BIT7_RasingEdge_Trig;
 197   3            trig_state=HIGH;
 198   3            Button_state=1;
 199   3          }else if(trig_state==HIGH && P17==HIGH){
 200   3            Enable_BIT7_FallEdge_Trig;
 201   3            trig_state=LOW;
 202   3            Button_state=0;
 203   3          }
 204   2          clr_PD;
 205   2        }
 206   1        return;
 207   1      }
 208          
 209          void EXT_INT0 (void) interrupt 0
 210          {
 211   1        Send_Data_To_UART0(0xAA);
 212   1      }
 213          
 214          int Head_Music_Play=0;
 215          int Body_Music_Play=0;
 216          void main (void) 
 217          {
 218   1        int music_num=1;
 219   1        Set_All_GPIO_Quasi_Mode;          // Define in Function_define.h
 220   1        
 221   1        InitialUART0_Timer1(9600);
 222   1        set_CLOEN; 
 223   1        Delay_1ms(50);
 224   1      
 225   1      #if 1
 226   1        P17_Input_Mode;
 227   1        set_P0S_7;
 228   1        Enable_INT_Port1;
 229   1        Enable_BIT7_FallEdge_Trig;
 230   1        trig_state=LOW;
 231   1      
C51 COMPILER V9.53.0.0   GPIO                                                              01/08/2018 19:20:12 PAGE 5   

 232   1        P30_Input_Mode;
 233   1        Enable_BIT0_FallEdge_Trig;
 234   1        //Enable_INT_Port3;
 235   1      
 236   1        set_EPI;              // Enable pin interrupt
 237   1        set_EX0;
 238   1        set_EA;               // global enable bit
 239   1      
 240   1      #endif
 241   1        Specify_Volume(15);
 242   1        //Control_CMD(chip_sleep,sizeof(chip_sleep));
 243   1        while(1){
 244   2          Button_state=-1;
 245   2          if(Head_Music_Play && Get_Play_State()==PLAYING){
 246   3            Delay_1ms(50);
 247   3          }else if(Body_Music_Play){
 248   3            Control_CMD(folder_and_num, sizeof(folder_and_num));
 249   3            //Specify_Volume(40);
 250   3            Head_Music_Play=0;
 251   3            Body_Music_Play=0;
 252   3          }else{
 253   3            Head_Music_Play=0;
 254   3            set_PD;
 255   3          }
 256   2          if(Button_state==1){
 257   3            folder_and_num[1]=1;
 258   3            folder_and_num[2]=0;
 259   3            Control_CMD(folder_and_num, sizeof(folder_and_num));
 260   3            
 261   3            Head_Music_Play=1;
 262   3          }else if(Button_state==0){
 263   3            folder_and_num[1]=1;
 264   3            folder_and_num[2]=music_num++;
 265   3            Body_Music_Play=1;
 266   3            if(music_num>12){
 267   4              music_num=1;
 268   4            }
 269   3          }
 270   2        }
 271   1      }
 272          
 273          
 274          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1442    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     60      47
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
