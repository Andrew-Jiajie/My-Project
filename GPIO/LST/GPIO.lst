C51 COMPILER V9.53.0.0   GPIO                                                              01/06/2018 18:16:54 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE GPIO
OBJECT MODULE PLACED IN .\Output\GPIO.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Code\GPIO.C LARGE OPTIMIZE(4,SPEED) BROWSE INCDIR(..\..\Include) DEFINE(
                    -FOSC_160000) DEBUG OBJECTEXTEND PRINT(.\LST\GPIO.lst) TABS(2) OBJECT(.\Output\GPIO.obj)

line level    source

   1          /*--------------------------------------------------------------------------------------------------------
             --*/
   2          /*                                                                                                        
             - */
   3          /* Copyright(c) 2017 Nuvoton Technology Corp. All rights reserved.                                        
             - */
   4          /*                                                                                                        
             - */
   5          /*--------------------------------------------------------------------------------------------------------
             --*/
   6          
   7          //********************************************************************************************************
             -***
   8          //  Website: http://www.nuvoton.com
   9          //  E-Mail : MicroC-8bit@nuvoton.com
  10          //  Date   : Jan/21/2017
  11          //********************************************************************************************************
             -***
  12          
  13          //********************************************************************************************************
             -***
  14          //  File Function: N76E003 GPIO demo code
  15          //********************************************************************************************************
             -***
  16          #include "N76E003.h"
  17          #include "SFR_Macro.h"
  18          #include "Function_define.h"
  19          #include "Common.h"
  20          #include "Delay.h"
  21          
  22          #define DEBUG 0
  23          #define HIGH 1
  24          #define LOW 0
  25          
  26          
  27          void Delay_1ms(int time)
  28          {
  29   1        int i,j;
  30   1        for(j=0; j<time; j++)
  31   1          for (i = 0; i < 729; i++);
  32   1      }
  33          
  34          void Delay_100us(int time)
  35          {
  36   1        int i,j;
  37   1        for(j=0; j<time; j++)
  38   1          for (i = 0; i < 72; i++);
  39   1      }
  40          
  41          /*------------------------------------------------
  42          The main C function.  Program execution starts
  43          here after stack initialization.
  44          ------------------------------------------------*/
  45          typedef unsigned char u8;
C51 COMPILER V9.53.0.0   GPIO                                                              01/06/2018 18:16:54 PAGE 2   

  46          u8 music_play[]={0x01};
  47          u8 music_stop[]={0x0E};
  48          u8 music_next[]={0x03};
  49          u8 volume_set[]={0x31,0x10};
  50          u8 source_TF[]={0x35,0x01};
  51          u8 source_FLASH[]={0x35,0x04};
  52          u8 music_in_root[]={0x34,0x03,0x01};
  53          u8 folder_and_num[]={0x42,0x02,0x01};
  54          u8 chip_sleep[]={0x35,0x03};
  55          u8 chip_wakeup[]={0x35,0x02};
  56          
  57          u8 music_state[]={0x10};
  58          u8 volume_get[]={0x11};
  59          
  60          u8 return_ok[]={0x7E,0x02,0x00,0xEF};
  61          u8 return_finished[]={0x7E,0x04,   0x3E,    0x00,0x00,0xEF};  //current music finished
  62          u8 return_state[]={0x7E,0x03,0x10,0x00,   //0(STOP) 1(PLAY) 2(PAUS) 3(FF) 4(FR)
  63                            0xEF,0x7E,0x02,0x00,0xEF}; //when music_state send, will return the value
  64          u8 state_str[12];
  65          u8 get_state()
  66          {
  67   1          int result_num=0;
  68   1        int timeout=250;
  69   1      
  70   1        while(!RI && timeout--){
  71   2          Delay_100us(1);   //delay 25ms
  72   2        }
  73   1          while (RI) {
  74   2            state_str[result_num++]=Receive_Data_From_UART0();
  75   2          timeout=8000;
  76   2          while(!RI && timeout--);
  77   2          }
  78   1          return result_num;
  79   1      }
  80          
  81          void send_cmd(u8* cmd, u8 num){
  82   1        u8 count=0;
  83   1        u8 command[15];
  84   1        u8 tmp_cnt=0;
  85   1        int out_cnt=0;
  86   1        
  87   1        command[count++]=0x7E;
  88   1        command[count++]=0x01+num;
  89   1        while(tmp_cnt<num){
  90   2          command[count++]=*(cmd+tmp_cnt);
  91   2          tmp_cnt++;
  92   2        }
  93   1        command[count]=0xEF;
  94   1        while(out_cnt<=count){
  95   2          Send_Data_To_UART0(command[out_cnt++]);
  96   2        }
  97   1      }
  98          
  99          void Control_CMD(u8* cmd, u8 num){
 100   1        int set_correct=0;
 101   1          u8 timeout=3;
 102   1          int str_num;
 103   1          int j;
 104   1          while(!set_correct && timeout--){
 105   2              send_cmd(cmd, num);
 106   2            str_num = get_state();
 107   2      #if DEBUG
C51 COMPILER V9.53.0.0   GPIO                                                              01/06/2018 18:16:54 PAGE 3   

                    Send_Data_To_UART0(0xAA);
                    for(j=0; j<str_num; j++){
                      Send_Data_To_UART0(state_str[j]);
                    }
                    Send_Data_To_UART0(0xBB);
              #endif
 114   2              for(j=0; j<str_num-3; j++){
 115   3                if(state_str[j]==0x7e && state_str[j+1]==0x02 && state_str[j+2]==0x00 && state_str[j+3]==0xef){
 116   4                    set_correct=1;
 117   4      #if DEBUG
                        Send_Data_To_UART0(0xCC);
              #endif
 120   4                      break;
 121   4                }
 122   3              }
 123   2          }
 124   1      
 125   1      }
 126          
 127          
 128          void Specify_Volume(u8 num)
 129          {
 130   1        
 131   1      #if 0
                volume_set[1] = num;
                Control_CMD(volume_set, sizeof(volume_set));
              #else
 135   1        int set_correct=0;
 136   1        u8 timeout=3;
 137   1        int str_num;
 138   1        int j;
 139   1        volume_set[1] = num;
 140   1        while(!set_correct && timeout--){
 141   2          send_cmd(volume_set, sizeof(volume_set));
 142   2        Delay_1ms(13);  // 13ms is the best timedelay for volume set!
 143   2          send_cmd(volume_get, sizeof(volume_get));
 144   2          str_num = get_state();
 145   2      #if DEBUG
                Send_Data_To_UART0(0xAA);
                for(j=0; j<str_num; j++){
                  Send_Data_To_UART0(state_str[j]);
                }
                Send_Data_To_UART0(0xBB);
              #endif
 152   2          for(j=0; j<str_num-3; j++){
 153   3            if(state_str[j]==0x7e && state_str[j+2]==0x11 && state_str[j+3]==num){
 154   4              set_correct=1;
 155   4      #if DEBUG
                  Send_Data_To_UART0(0xCC);
              #endif
 158   4              break;
 159   4            }
 160   3          }
 161   2        }
 162   1      #endif
 163   1      }
 164          
 165          int trig_state=HIGH;
 166          void set_trig_state(){
 167   1        if(trig_state==0){
 168   2          Enable_BIT7_HighLevel_Trig;
 169   2          trig_state=1;
C51 COMPILER V9.53.0.0   GPIO                                                              01/06/2018 18:16:54 PAGE 4   

 170   2        }else if(trig_state==1){
 171   2          Enable_BIT7_LowLevel_Trig;
 172   2          trig_state=0;
 173   2        }
 174   1      }
 175          
 176          int Button_state=-1;
 177          void PinInterrupt_ISR (void) interrupt 7
 178          {
 179   1        if (PIF == 0x80)
 180   1        {
 181   2          PIF =0;
 182   2          Delay_1ms(15);
 183   2          if(trig_state==LOW && P17==LOW){
 184   3            Enable_BIT7_RasingEdge_Trig;
 185   3            trig_state=HIGH;
 186   3            Button_state=1;
 187   3          }
 188   2          if(trig_state==HIGH && P17==HIGH){
 189   3            Enable_BIT7_FallEdge_Trig;
 190   3            trig_state=LOW;
 191   3            Button_state=0;
 192   3          }
 193   2          clr_PD;
 194   2        }
 195   1        return;
 196   1      }
 197          
 198          void EXT_INT0 (void) interrupt 0
 199          {
 200   1        Send_Data_To_UART0(0xAA);
 201   1      }
 202          
 203          void main (void) 
 204          {
 205   1        int  Pin_last_state;
 206   1        int music_num=1;
 207   1        Set_All_GPIO_Quasi_Mode;          // Define in Function_define.h
 208   1        
 209   1      #if 1
 210   1        InitialUART0_Timer1(9600);
 211   1        set_CLOEN; 
 212   1        Delay_1ms(50);
 213   1        //Specify_Volume(15);
 214   1        //send_cmd(music_play, sizeof(music_play));
 215   1      #if 1
 216   1      P17_Input_Mode;
 217   1      set_P0S_7;
 218   1      Enable_INT_Port1;
 219   1      Enable_BIT7_FallEdge_Trig;
 220   1      trig_state=LOW;
 221   1      //set_trig_state();
 222   1      
 223   1      P30_Input_Mode;
 224   1      Enable_BIT0_FallEdge_Trig;
 225   1      //Enable_INT_Port3;
 226   1      
 227   1      set_EPI;              // Enable pin interrupt
 228   1      set_EX0;
 229   1      set_EA;               // global enable bit
 230   1      
 231   1      #endif
C51 COMPILER V9.53.0.0   GPIO                                                              01/06/2018 18:16:54 PAGE 5   

 232   1        
 233   1        Pin_last_state=P17;
 234   1        //Control_CMD(chip_sleep,sizeof(chip_sleep));
 235   1        while(1){
 236   2          Delay_1ms(15);
 237   2          Send_Data_To_UART0(P17);
 238   2          #if 0
                  if(Pin_last_state==1 && P17==0){
                    Button_state=1;
                  }
                  if(Pin_last_state==0 && P17==1){
                    Button_state=0;
                  }
                  #endif
 246   2          Pin_last_state=P17;
 247   2          Button_state=-1;
 248   2          set_PD;
 249   2          if(Button_state==1){
 250   3            //println("pressed");
 251   3            folder_and_num[1]=1;
 252   3            folder_and_num[2]=0;
 253   3            Control_CMD(folder_and_num, sizeof(folder_and_num));
 254   3            //send_cmd(music_next, sizeof(music_next));
 255   3            Specify_Volume(40);
 256   3          }
 257   2          if(Button_state==0){
 258   3            //println("released");
 259   3            folder_and_num[1]=1;
 260   3            folder_and_num[2]=music_num;
 261   3            music_num++;
 262   3            Control_CMD(folder_and_num, sizeof(folder_and_num));
 263   3            //send_cmd(music_next, sizeof(music_next));
 264   3            Specify_Volume(40);
 265   3            if(music_num>12){
 266   4              music_num=1;
 267   4            }
 268   3      
 269   3          }
 270   2        }
 271   1      #endif
 272   1      }
 273          
 274          
 275          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1345    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     56      48
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
