C51 COMPILER V9.53.0.0   GPIO                                                              01/28/2018 19:26:54 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE GPIO
OBJECT MODULE PLACED IN .\Output\GPIO.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Code\GPIO.C LARGE OPTIMIZE(4,SPEED) BROWSE INCDIR(..\..\Include) DEFINE(
                    -FOSC_160000) DEBUG OBJECTEXTEND PRINT(.\LST\GPIO.lst) TABS(2) OBJECT(.\Output\GPIO.obj)

line level    source

   1          /*--------------------------------------------------------------------------------------------------------
             --*/
   2          /*                                                                                                        
             - */
   3          /* Copyright(c) 2017 Nuvoton Technology Corp. All rights reserved.                                        
             - */
   4          /*                                                                                                        
             - */
   5          /*--------------------------------------------------------------------------------------------------------
             --*/
   6          
   7          //********************************************************************************************************
             -***
   8          //  Website: http://www.nuvoton.com
   9          //  E-Mail : MicroC-8bit@nuvoton.com
  10          //  Date   : Jan/21/2017
  11          //********************************************************************************************************
             -***
  12          
  13          //********************************************************************************************************
             -***
  14          //  File Function: N76E003 GPIO demo code
  15          //********************************************************************************************************
             -***
  16          #include "N76E003.h"
  17          #include "SFR_Macro.h"
  18          #include "Function_define.h"
  19          #include "Common.h"
  20          #include "Delay.h"
  21          
  22          #define DEBUG 0
  23          #define HIGH 1
  24          #define LOW 0
  25          
  26          #define PLAYING 1
  27          #define STOP 0
  28          #define ON 1
  29          #define OFF 0
  30          #define SOURCE_TF 2
  31          #define SOURCE_FLASH 3
  32          #define MINIT   60
  33          
  34          #define HEAD_MUSIC_NUM 2
  35          
  36          void Delay_1ms(int time)
  37          {
  38   1        int i,j;
  39   1        for(j=0; j<time; j++)
  40   1          for (i = 0; i < 729; i++);
  41   1      }
  42          
  43          void Delay_100us(int time)
  44          {
  45   1        int i,j;
C51 COMPILER V9.53.0.0   GPIO                                                              01/28/2018 19:26:54 PAGE 2   

  46   1        for(j=0; j<time; j++)
  47   1          for (i = 0; i < 72; i++);
  48   1      }
  49          
  50          /*------------------------------------------------
  51          The main C function.  Program execution starts
  52          here after stack initialization.
  53          ------------------------------------------------*/
  54          typedef unsigned char u8;
  55          u8 music_play[]={0x01};
  56          u8 music_stop[]={0x0E};
  57          u8 music_next[]={0x03};
  58          u8 volume_set[]={0x31,0x10};
  59          u8 source_TF[]={0x35,0x01};
  60          u8 source_FLASH[]={0x35,0x04};
  61          u8 music_for_head[]={0x42,0x01,0x01};
  62          u8 music_for_next[]={0x41,0x00,0x01};
  63          u8 music_in_root[]={0x41,0x00,0x01};
  64          u8 folder_and_num[]={0x42,0x01,0x01};
  65          u8 chip_sleep[]={0x35,0x03};
  66          u8 chip_wakeup[]={0x35,0x02};
  67          
  68          u8 music_state[]={0x10};
  69          u8 music_number[]={0x17};
  70          u8 volume_get[]={0x11};
  71          u8 current_source[]={0x18};
  72          
  73          u8 return_ok[]={0x7E,0x02,0x00,0xEF};
  74          u8 return_finished[]={0x7E,0x04,   0x3E,    0x00,0x00,0xEF};  //current music finished
  75          u8 return_state[]={0x7E,0x03,0x10,0x00,   //0(STOP) 1(PLAY) 2(PAUS) 3(FF) 4(FR)
  76                            0xEF,0x7E,0x02,0x00,0xEF}; //when music_state send, will return the value
  77          u8 state_str[12];
  78          u8 get_result()
  79          {
  80   1          int result_num=0;
  81   1        int timeout=250;
  82   1      
  83   1        while(!RI && timeout--){
  84   2          Delay_100us(1);   //delay 25ms
  85   2        }
  86   1          while (RI) {
  87   2            state_str[result_num++]=Receive_Data_From_UART0();
  88   2          timeout=8000;
  89   2          while(!RI && timeout--);
  90   2          }
  91   1          return result_num;
  92   1      }
  93          
  94          void send_cmd(u8* cmd, u8 num){
  95   1        u8 count=0;
  96   1        u8 command[15];
  97   1        u8 tmp_cnt=0;
  98   1        int out_cnt=0;
  99   1        
 100   1        command[count++]=0x7E;
 101   1        command[count++]=0x01+num;
 102   1        while(tmp_cnt<num){
 103   2          command[count++]=*(cmd+tmp_cnt);
 104   2          tmp_cnt++;
 105   2        }
 106   1        command[count]=0xEF;
 107   1        while(out_cnt<=count){
C51 COMPILER V9.53.0.0   GPIO                                                              01/28/2018 19:26:54 PAGE 3   

 108   2          Send_Data_To_UART0(command[out_cnt++]);
 109   2        }
 110   1      }
 111          
 112          int Control_CMD(u8* cmd, u8 num){
 113   1        int set_correct=0;
 114   1          u8 timeout=2;
 115   1          int str_num;
 116   1          int j;
 117   1          while(!set_correct && timeout--){
 118   2              send_cmd(cmd, num);
 119   2            str_num = get_result();
 120   2              for(j=0; j<str_num-3; j++){
 121   3                if(state_str[j]==0x7e && state_str[j+1]==0x02 && state_str[j+2]==0x00 && state_str[j+3]==0xef){
 122   4                    set_correct=1;
 123   4              return 0;
 124   4                      break;
 125   4                }
 126   3              }
 127   2          }
 128   1        return -1;
 129   1      }
 130          
 131          
 132          int Get_Play_State()
 133          {
 134   1          u8 timeout=2;
 135   1        int str_num;
 136   1        int j;
 137   1        
 138   1          while(timeout--){
 139   2            send_cmd(music_state, sizeof(music_state));
 140   2            str_num = get_result();
 141   2            for(j=0; j<str_num-3; j++){
 142   3                if(state_str[j]==0x7e && state_str[j+2]==0x10){
 143   4                  return state_str[j+3];
 144   4                }
 145   3            }
 146   2          Delay_1ms(20);
 147   2          }
 148   1        return -1;
 149   1      }
 150          
 151          int Get_total_number()
 152          {
 153   1          u8 timeout=2;
 154   1        int str_num;
 155   1        int j;
 156   1        
 157   1          while(timeout--){
 158   2            send_cmd(music_number, sizeof(music_number));
 159   2            str_num = get_result();
 160   2            for(j=0; j<str_num-4; j++){
 161   3                if(state_str[j]==0x7e && state_str[j+2]==0x17){
 162   4              return state_str[j+4];
 163   4                }
 164   3            }
 165   2          Delay_1ms(20);
 166   2          }
 167   1        return -1;
 168   1      }
 169          
C51 COMPILER V9.53.0.0   GPIO                                                              01/28/2018 19:26:54 PAGE 4   

 170          int play_head_music(){
 171   1        Control_CMD(music_for_head, sizeof(music_for_head));
 172   1        music_for_head[2]++;
 173   1        if(LOBYTE(music_for_head[2])>HEAD_MUSIC_NUM){
 174   2          music_for_head[2]=1;
 175   2        }
 176   1      }
 177          
 178          int play_body_music()
 179          {
 180   1        int total_music=Get_total_number();
 181   1        if(total_music > HEAD_MUSIC_NUM){
 182   2          Control_CMD(music_for_next, sizeof(music_for_next));
 183   2          music_for_next[2]++;
 184   2          if(LOBYTE(music_for_next[2])>total_music-HEAD_MUSIC_NUM){
 185   3            music_for_next[2]=1;
 186   3          }
 187   2        }
 188   1      }
 189          
 190          int Specify_Volume(u8 num)
 191          {
 192   1        
 193   1      #if 0
                volume_set[1] = num;
                Control_CMD(volume_set, sizeof(volume_set));
              #else
 197   1          int set_correct=0;
 198   1          u8 timeout=3;
 199   1        int str_num;
 200   1        int j;
 201   1        volume_set[1] = num;
 202   1        
 203   1          while(!set_correct && timeout--){
 204   2            send_cmd(volume_set, sizeof(volume_set));
 205   2          Delay_1ms(13);  // 13ms is the best timedelay for volume set!
 206   2            send_cmd(volume_get, sizeof(volume_get));
 207   2            str_num = get_result();
 208   2            for(j=0; j<str_num-3; j++){
 209   3                if(state_str[j]==0x7e && state_str[j+2]==0x11 && state_str[j+3]==num){
 210   4                  set_correct=1;
 211   4              return 0;
 212   4                }
 213   3            }
 214   2          }
 215   1        return -1;
 216   1      #endif
 217   1      }
 218          
 219          #define setbit(x,y) x|=(1<<y) //将X的第Y位置1
 220          #define testbit(x,y) x&(1<<y) //测试X的第Y位置
 221          #define clrbit(x,y) x&=!(1<<y) //将X的第Y位清0
 222          
 223          int button_trig_state=HIGH;
 224          int play_trig_state=HIGH;
 225          int charge_trig_state=HIGH;
 226          
 227          int Button_state=-1;
 228          int Play_state=STOP;
 229          int Charge_state=OFF;
 230          void PinInterrupt_ISR (void) interrupt 7
 231          {
C51 COMPILER V9.53.0.0   GPIO                                                              01/28/2018 19:26:54 PAGE 5   

 232   1        if (testbit(PIF,7)) //SWITCH PIN
 233   1        {
 234   2          clrbit(PIF,7);
 235   2          Delay_1ms(15);
 236   2          if(button_trig_state==LOW && P17==LOW){
 237   3            Enable_BIT7_RasingEdge_Trig;
 238   3            button_trig_state=HIGH;
 239   3            Button_state=1;
 240   3          }else if(button_trig_state==HIGH && P17==HIGH){
 241   3            Enable_BIT7_FallEdge_Trig;
 242   3            button_trig_state=LOW;
 243   3            Button_state=0;
 244   3          }
 245   2          clr_PD;
 246   2        }
 247   1        if (testbit(PIF,3)) //BUSY PIN
 248   1        {
 249   2          clrbit(PIF,3);
 250   2          Delay_1ms(2);
 251   2          if(play_trig_state==LOW && P13==LOW){
 252   3            Enable_BIT3_RasingEdge_Trig;
 253   3            play_trig_state=HIGH;
 254   3            Play_state=PLAYING;
 255   3          }else if(play_trig_state==HIGH && P13==HIGH){
 256   3            Enable_BIT3_FallEdge_Trig;
 257   3            play_trig_state=LOW;
 258   3            Play_state=STOP;
 259   3          }
 260   2          //Send_Data_To_UART0(0xcc);
 261   2          clr_PD;
 262   2        }
 263   1        if (testbit(PIF,2)) //USB PIN
 264   1        {
 265   2          clrbit(PIF,2);
 266   2          Delay_1ms(10);
 267   2          if(charge_trig_state==LOW && P13==LOW){
 268   3            Enable_BIT2_RasingEdge_Trig;
 269   3            charge_trig_state=HIGH;
 270   3            Charge_state=ON;
 271   3          }else if(charge_trig_state==HIGH && P13==HIGH){
 272   3            Enable_BIT2_FallEdge_Trig;
 273   3            charge_trig_state=LOW;
 274   3            Charge_state=OFF;
 275   3          }
 276   2          //Send_Data_To_UART0(0xcc);
 277   2          clr_PD;
 278   2        }
 279   1        return;
 280   1      }
 281          
 282          unsigned long wake_time=0;
 283          unsigned long timer_count=0;
 284          int Power_state=ON;
 285          
 286          /*********************************************************************************************************
             -***
 287          *    TIMER 0 interrupt subroutine
 288          **********************************************************************************************************
             -**/
 289          void Timer0_ISR (void) interrupt 1          //interrupt address is 0x000B
 290          {
 291   1          clr_TF0;
C51 COMPILER V9.53.0.0   GPIO                                                              01/28/2018 19:26:54 PAGE 6   

 292   1          clr_TR0;                                    //Stop Timer0
 293   1              TL0 = LOBYTE(TIMER_DIV12_VALUE_40ms);     //Find  define in "Function_define.h" "TIMER VALUE"
 294   1              TH0 = HIBYTE(TIMER_DIV12_VALUE_40ms);
 295   1          set_TR0;                                    //Start Timer0
 296   1          timer_count+=40;
 297   1          if(timer_count >= 1000){
 298   2            timer_count=0;
 299   2            wake_time++;
 300   2          }
 301   1          //Send_Data_To_UART0(0xcc);
 302   1      }
 303          
 304          void audio_power_on()
 305          {
 306   1        int timeout=25; //500ms for timeout
 307   1        int chip_ready=-1;
 308   1        P11=HIGH;
 309   1        while(timeout-- && chip_ready==-1){
 310   2          Delay_1ms(20);
 311   2          chip_ready=Specify_Volume(15);
 312   2          //Send_Data_To_UART0(0xCC);
 313   2        }
 314   1        Delay_1ms(110);
 315   1        Power_state=ON;
 316   1      }
 317          
 318          void audio_power_off()
 319          {
 320   1        clr_TR0;                                    //Stop Timer0
 321   1        wake_time=0;
 322   1        P11=LOW;
 323   1        Power_state=OFF;
 324   1        Send_Data_To_UART0(0xBB);
 325   1        set_PD;
 326   1        set_TR0;                                    //Timer0 run
 327   1      }
 328          
 329          int Head_Music_Play=0;
 330          int Body_Music_Play=0;
 331          void main (void) 
 332          {
 333   1        int music_num=1;
 334   1        int play_state=-1;
 335   1        
 336   1        //set_PD;                 //powerdown directly 131.5uA
 337   1        Set_All_GPIO_Quasi_Mode;          // Define in Function_define.h
 338   1        P11_PushPull_Mode;
 339   1      
 340   1        InitialUART0_Timer1(9600);
 341   1        set_CLOEN; 
 342   1        audio_power_on();
 343   1        //Delay_1ms(250);     //800ms delay for audio chip get ready
 344   1      
 345   1      #if 1
 346   1        TIMER0_MODE0_ENABLE;                        //Timer 0 and Timer 1 mode configuration
 347   1      
 348   1        clr_T0M;
 349   1          TMOD |= 0x01;                               //Timer0 is 16-bit mode
 350   1        
 351   1          TL0 = LOBYTE(TIMER_DIV12_VALUE_40ms);     //Find  define in "Function_define.h" "TIMER VALUE"
 352   1          TH0 = HIBYTE(TIMER_DIV12_VALUE_40ms);
 353   1          
C51 COMPILER V9.53.0.0   GPIO                                                              01/28/2018 19:26:54 PAGE 7   

 354   1        set_ET0;                                    //enable Timer0 interrupt
 355   1        set_EA;                                     //enable interrupts
 356   1        
 357   1        set_TR0;                                    //Timer0 run
 358   1      #endif
 359   1      
 360   1      #if 1
 361   1        P17_Input_Mode;
 362   1        set_P0S_7;
 363   1        Enable_BIT7_FallEdge_Trig;
 364   1        button_trig_state=LOW;
 365   1      
 366   1        P13_Input_Mode;
 367   1        set_P0S_3;
 368   1        Enable_BIT3_FallEdge_Trig;
 369   1        play_trig_state=LOW;
 370   1        
 371   1        
 372   1        P30_Input_Mode;
 373   1        Enable_BIT0_FallEdge_Trig;
 374   1      
 375   1        Enable_INT_Port1;
 376   1        set_EPI;              // Enable pin interrupt
 377   1        set_EX0;
 378   1        set_EA;               // global enable bit
 379   1      
 380   1      #endif
 381   1        Specify_Volume(15);
 382   1        //Control_CMD(folder_and_num, sizeof(folder_and_num));
 383   1        while(1){
 384   2          //set_PD;         //powerdown here can be 145.8uA
 385   2          //play_state=Get_Play_State();
 386   2          if(Button_state==1){
 387   3            Button_state=-1;
 388   3            if(Power_state==OFF){
 389   4              audio_power_on();
 390   4            }
 391   3            play_head_music();
 392   3            //Head_Music_Play=1;
 393   3            Body_Music_Play=0;
 394   3          }
 395   2          if(Button_state==0){
 396   3            Button_state=-1;
 397   3            Body_Music_Play=1;
 398   3          }
 399   2          if(Play_state==PLAYING || Charge_state==ON){
 400   3            wake_time = 0;
 401   3            //Send_Data_To_UART0(0xBB);
 402   3            set_IDL;
 403   3          }
 404   2          if(Charge_state==ON && Power_state==OFF){
 405   3            audio_power_on();
 406   3          }
 407   2          if(Play_state==STOP && Charge_state==OFF && wake_time > 1*MINIT){
 408   3            audio_power_off();
 409   3          }
 410   2      #if 0
                  if(Play_state==STOP && Head_Music_Play==1){
                    Head_Music_Play=0;
                  }
              #endif
 415   2          if(Play_state==STOP && Body_Music_Play==1){
C51 COMPILER V9.53.0.0   GPIO                                                              01/28/2018 19:26:54 PAGE 8   

 416   3            if(Power_state==ON){
 417   4              play_body_music();
 418   4            }
 419   3            Body_Music_Play=0;
 420   3          }
 421   2        }
 422   1      }
*** WARNING C290 IN LINE 176 OF Code\GPIO.C: missing return value
*** WARNING C290 IN LINE 188 OF Code\GPIO.C: missing return value


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2208    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     86      56
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
